#' Pruning of input matrix, given iteration log and optimum quality score
#'
#' Densifies the (original) input data matrix given the iteration log and the optimum quality score retrieved from the `densify_steps` and `densify_score` functions by pruning the appropriate rows and columns.
#'
#' @param original_data A data frame with the observation names as row names and variable names as column names.
#' @param iteration_log A data frame containing the iteration_log generated by `densify_steps`.
#' @param optimum The iteration number representing the optimum quality score determined by `densify_score`. The function will densify the matrix and prune rows and columns up to this iteration. Default is set to 1 (output is original data frame).
#'
#' @return A pruned and densified data frame.
#'
#' @seealso \code{\link{densify_steps}}
#' @seealso \code{\link{densify_score}}
#'
#' @examples
#' # Assuming 'original_data' and 'iteration_log' are prepared
#' # pruned_densified <- densify_prune(original_data, iteration_log, optimum = 2)
#' @import dplyr
#' @export

densify_prune <- function(original_data, iteration_log, optimum = 1) {
  # Validate inputs:
  if (!is.data.frame(original_data)) {
    stop("The 'original_data' parameter must be a data frame.")
  }
  if (!is.data.frame(iteration_log)) {
    stop("The 'iteration_log' parameter must be a data frame.")
  }
  if (!is.integer(optimum) || optimum < 1) {
    stop("The 'optimum' parameter must be a strictly positive integer.")
  }

  # Ensure 'optimum' is not greater than the number of iterations in 'iteration_log':
  num_iterations <- nrow(iteration_log)
  if (optimum > num_iterations) {
    warning("The 'optimum' value was larger than the number of iterations in iteration_log.")
    optimum <- num_iterations
  }

  # Extract relevant iteration_log up to the optimum iteration:
  iteration_log <- dplyr::slice(iteration_log, 1:optimum)

  # Process removed languages and variables:
  prune_taxa <- unique(unlist(strsplit(iteration_log$removed_tax, ";")))[unique(unlist(strsplit(iteration_log$removed_tax, ";"))) != "NA"]
  prune_vars <- unique(unlist(strsplit(iteration_log$removed_var, ";")))[unique(unlist(strsplit(iteration_log$removed_var, ";"))) != "NA"]

  # Create the pruned matrix by removing specified languages and variables:
  pruned_matrix <- original_data[which(rownames(original_data)%in%prune_taxa==F),which(colnames(original_data)%in%prune_vars==F)]

  return(pruned_matrix)
}
