#' Pruning of input matrix, given iteration log and optimum quality score
#'
#' Densifies the (original) input data matrix given the iteration log and the optimum quality score retrieved from the `densify_steps` and `densify_score` functions by pruning the appropriate rows and columns.
#'
#' @param original_data A data frame with the observation names as row names and variable names as column names.
#' @param iteration_log A data frame containing the iteration_log generated by `densify_steps`.
#' @param optimum The iteration number representing the optimum quality score determined by `densify_score`. The function will densify the matrix and prune rows and columns up to this iteration. Default is set to 1 (output is original data frame).
#'
#' @return A pruned and densified data frame.
#'
#' @seealso \code{\link{densify_steps}}
#' @seealso \code{\link{densify_score}}
#'
#' @examples
#' # Assuming 'original_data' and 'iteration_log' are prepared
#' # pruned_densified <- densify_prune(original_data, iteration_log, optimum = 2)
#' @import dplyr
#' @export
densify_prune <- function(original_data, iteration_log, optimum = 1) {
  # Validate inputs:
  if (!is.data.frame(original_data)) {
    rlang::abort("`original_data` must be a data frame")
  }
  if (!is.data.frame(iteration_log)) {
    rlang::abort("`iteration_log` must be a data frame")
  }
  if (!rlang::is_integerish(optimum) || optimum < 1) {
    rlang::abort("'optimum' must be a strictly positive integer")
  }
  optimum <- as.integer(optimum)

  # Ensure 'optimum' is not greater than the number of iterations in 'iteration_log':
  num_iterations <- nrow(iteration_log)

  print(optimum)
  print(num_iterations)

  if (optimum > num_iterations) {
    rlang::warn(c(
      "`optimum` is larger than the number of iterations in iteration_log",
      "!" = sprintf("resetting to the number of iterations %s", num_iterations)
    ))
    optimum <- num_iterations
  }

  # Extract relevant iteration_log up to the optimum iteration:
  iteration_log <- dplyr::slice(iteration_log, 1:optimum)

  # Process removed languages and variables:
  prune_taxa <- unique(unlist(strsplit(iteration_log$removed_tax, ";")))[unique(unlist(strsplit(iteration_log$removed_tax, ";"))) != "NA"]
  prune_vars <- unique(unlist(strsplit(iteration_log$removed_var, ";")))[unique(unlist(strsplit(iteration_log$removed_var, ";"))) != "NA"]

  # Create the pruned matrix by removing specified languages and variables:
  pruned_matrix <- original_data[which(rownames(original_data)%in%prune_taxa==F),which(colnames(original_data)%in%prune_vars==F)]

  pruned_matrix
}
